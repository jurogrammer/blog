<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AOP on My New Hugo Site</title><link>https://jurogrammer.github.io/blog/tags/aop/</link><description>Recent content in AOP on My New Hugo Site</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 27 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://jurogrammer.github.io/blog/tags/aop/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring AOP Self-Invocation Problem and a Kotlinic Workaround</title><link>https://jurogrammer.github.io/blog/languages/kotlin/spring-aop-self-invocation-problem-and-a-kotlinic-workaround/</link><pubDate>Mon, 27 May 2024 00:00:00 +0000</pubDate><guid>https://jurogrammer.github.io/blog/languages/kotlin/spring-aop-self-invocation-problem-and-a-kotlinic-workaround/</guid><description>&lt;h2 id="spring-aop-problem">Spring AOP Problem&lt;/h2>
&lt;p>In Spring, &lt;strong>self-invocation&lt;/strong> refers to a method within a class calling another method of the same class. This can be problematic when using AOP (Aspect-Oriented Programming) annotations like &lt;strong>@Transactional&lt;/strong>.&lt;/p>
&lt;p>Spring AOP is proxy-based. So if you call another method directly within the same class, it bypasses the proxy, and AOP annotations won&amp;rsquo;t be applied.&lt;/p>
&lt;p>For example, suppose you have method &lt;code>A&lt;/code> annotated with &lt;code>@Transactional&lt;/code>, and it&amp;rsquo;s called from method &lt;code>B&lt;/code> in the same class. If method &lt;code>B&lt;/code> calls &lt;code>A&lt;/code> directly, Spring won’t manage the transaction properly because the call doesn’t go through the proxy.&lt;/p></description></item></channel></rss>